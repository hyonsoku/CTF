# エンコード・デコード

- [CodExt](https://github.com/dhondta/python-codext)

# 古典暗号

# RSA

- [factordb](http://www.factordb.com/): 素因数分解をしてくれるツール
- [RsaCtfTool](https://github.com/RsaCtfTool/RsaCtfTool)

# Hash

# XOR暗号化

XOR（排他的論理和）演算は、2つのビットが異なる場合に1を返し、同じ場合には0を返す論理演算です。この特性を利用して、平文（暗号化前のメッセージ）と鍵を組み合わせることで暗号文（暗号化後のメッセージ）を生成します。

## シングルバイトXOR暗号化

シングルバイトXOR暗号化は、最もシンプルな形のXOR暗号化手法です。この方法では、1バイト（8ビット）の鍵を使用して、メッセージ全体を暗号化します。

### 暗号化の仕組み

1. 平文のビット表現
まず、平文の各文字をASCIIコードに変換し、その後ビット表現にします。

```text
F: 01000110
L: 01001100
A: 01000001
G: 01000111
```

2. 鍵のビット表現
鍵 'A' のビット表現は次の通りです。

```text
A: 01000001
```

3. XOR演算による暗号化
各文字のビット表現に対して、鍵のビットをXOR演算します。XOR演算は、ビットが異なる場合に1を、同じ場合に0を返します。

```text
F:  01000110
A:  01000001
-----------------
XOR: 00000111  (暗号化されたビット)

L:  01001100
A:  01000001
-----------------
XOR: 00001101  (暗号化されたビット)

A:  01000001
A:  01000001
-----------------
XOR: 00000000  (暗号化されたビット)

G:  01000111
A:  01000001
-----------------
XOR: 00000110  (暗号化されたビット)
```

4. 結果のまとめ
暗号化されたビットは次のようになります。

```text
暗号文:
00000111 (BEL)
00001101 (CR)
00000000 (NUL)
00000110 (ACK)
```

これを10進数に変換すると、暗号文は BEL, CR, NUL, ACK となります。

シングルバイトXOR暗号化の大きな利点は、同じ鍵を使って再度XOR演算を行うことで、元の平文を簡単に復元できる点です。

```text
BEL:  00000111
A:    01000001
-----------------
XOR:  01000110 (F)

CR:   00001101
A:    01000001
-----------------
XOR:  01001100 (L)

NUL:  00000000
A:    01000001
-----------------
XOR:  01000001 (A)

ACK:  00000110
A:    01000001
-----------------
XOR:  01000111 (G)
```

このように、復号化された結果は元の平文 "FLAG" になります。